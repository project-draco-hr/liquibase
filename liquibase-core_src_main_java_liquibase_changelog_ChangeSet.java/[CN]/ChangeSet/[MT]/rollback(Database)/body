{
  try {
    Executor executor=ExecutorService.getInstance().getExecutor(database);
    executor.comment("Rolling Back ChangeSet: " + toString());
    if (database.supportsDDLInTransaction()) {
      database.setAutoCommit(!runInTransaction);
    }
    RanChangeSet ranChangeSet=database.getRanChangeSet(this);
    if (rollBackChanges != null && rollBackChanges.size() > 0) {
      for (      Change rollback : rollBackChanges) {
        if (((rollback instanceof DbmsTargetedChange)) && !DatabaseList.definitionMatches(((DbmsTargetedChange)rollback).getDbms(),database,true)) {
          continue;
        }
        SqlStatement[] statements=rollback.generateStatements(database);
        if (statements == null) {
          continue;
        }
        for (        SqlStatement statement : statements) {
          try {
            executor.execute(statement,sqlVisitors);
          }
 catch (          DatabaseException e) {
            throw new RollbackFailedException("Error executing custom SQL [" + statement + "]",e);
          }
        }
      }
    }
 else {
      List<Change> changes=getChanges();
      for (int i=changes.size() - 1; i >= 0; i--) {
        Change change=changes.get(i);
        database.executeRollbackStatements(change,sqlVisitors);
      }
    }
    if (runInTransaction) {
      database.commit();
    }
    log.debug("ChangeSet " + toString() + " has been successfully rolled back.");
  }
 catch (  Exception e) {
    try {
      database.rollback();
    }
 catch (    DatabaseException e1) {
    }
    throw new RollbackFailedException(e);
  }
 finally {
    if (!runInTransaction && database.supportsDDLInTransaction()) {
      try {
        database.setAutoCommit(false);
      }
 catch (      DatabaseException e) {
        throw new RollbackFailedException("Could not resetInternalState autocommit",e);
      }
    }
  }
}
