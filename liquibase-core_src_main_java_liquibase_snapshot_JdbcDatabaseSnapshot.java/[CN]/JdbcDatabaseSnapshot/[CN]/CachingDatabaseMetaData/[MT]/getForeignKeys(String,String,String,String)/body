{
  return getResultSetCache("getImportedKeys").get(new ResultSetCache.UnionResultSetExtractor(database){
    @Override public ResultSetCache.RowData rowKeyParameters(    CachedRow row){
      return new ResultSetCache.RowData(row.getString("FKTABLE_CAT"),row.getString("FKTABLE_SCHEM"),database,row.getString("FKTABLE_NAME"),row.getString("FK_NAME"));
    }
    @Override public ResultSetCache.RowData wantedKeyParameters(){
      return new ResultSetCache.RowData(catalogName,schemaName,database,tableName,fkName);
    }
    @Override public List<CachedRow> fastFetch() throws SQLException, DatabaseException {
      CatalogAndSchema catalogAndSchema=new CatalogAndSchema(catalogName,schemaName).customize(database);
      List<CachedRow> returnList=new ArrayList<CachedRow>();
      List<String> tables=new ArrayList<String>();
      String jdbcCatalogName=((AbstractJdbcDatabase)database).getJdbcCatalogName(catalogAndSchema);
      String jdbcSchemaName=((AbstractJdbcDatabase)database).getJdbcSchemaName(catalogAndSchema);
      if (database instanceof DB2Database) {
        String sql=getDB2Sql(jdbcSchemaName);
        if (tableName != null) {
          sql=sql.replace(" ORDER BY "," AND fk_col.tabname='" + tableName + "' ORDER BY ");
        }
        return executeAndExtract(sql,database);
      }
 else {
        if (tableName == null) {
          for (          CachedRow row : getTables(jdbcCatalogName,jdbcSchemaName,null)) {
            tables.add(row.getString("TABLE_NAME"));
          }
        }
 else {
          tables.add(tableName);
        }
        for (        String foundTable : tables) {
          if (database instanceof OracleDatabase) {
            throw new RuntimeException("Should have bulk selected");
          }
 else {
            returnList.addAll(extract(databaseMetaData.getImportedKeys(jdbcCatalogName,jdbcSchemaName,foundTable)));
          }
        }
        return returnList;
      }
    }
    @Override public List<CachedRow> bulkFetch() throws SQLException, DatabaseException {
      if (database instanceof OracleDatabase) {
        CatalogAndSchema catalogAndSchema=new CatalogAndSchema(catalogName,schemaName).customize(database);
        String jdbcSchemaName=((AbstractJdbcDatabase)database).getJdbcSchemaName(catalogAndSchema);
        String sql="SELECT  /*+rule*/" + "  NULL AS pktable_cat,  " + "  p.owner as pktable_schem,  "+ "  p.table_name as pktable_name,  "+ "  pc.column_name as pkcolumn_name,  "+ "  NULL as fktable_cat,  "+ "  f.owner as fktable_schem,  "+ "  f.table_name as fktable_name,  "+ "  fc.column_name as fkcolumn_name,  "+ "  fc.position as key_seq,  "+ "  NULL as update_rule,  "+ "  decode (f.delete_rule, 'CASCADE', 0, 'SET NULL', 2, 1) as delete_rule,  "+ "  f.constraint_name as fk_name,  "+ "  p.constraint_name as pk_name,  "+ "  decode(f.deferrable, 'DEFERRABLE', 5, 'NOT DEFERRABLE', 7, 'DEFERRED', 6) deferrability  "+ "FROM "+ "all_cons_columns pc "+ "INNER JOIN all_constraints p "+ "ON pc.owner = p.owner "+ "AND pc.constraint_name = p.constraint_name "+ "INNER JOIN all_constraints f "+ "ON pc.owner = f.r_owner "+ "AND pc.constraint_name = f.r_constraint_name "+ "INNER JOIN all_cons_columns fc "+ "ON fc.owner = f.owner "+ "AND fc.constraint_name = f.constraint_name "+ "AND fc.position = pc.position "+ "WHERE f.owner = '" + jdbcSchemaName + "' "+ "AND p.constraint_type in ('P', 'U') "+ "AND f.constraint_type = 'R' "+ "AND p.table_name NOT LIKE 'BIN$%' "+ "ORDER BY fktable_schem, fktable_name, key_seq";
        return executeAndExtract(sql,database);
      }
 else       if (database instanceof DB2Database) {
        CatalogAndSchema catalogAndSchema=new CatalogAndSchema(catalogName,schemaName).customize(database);
        String jdbcSchemaName=((AbstractJdbcDatabase)database).getJdbcSchemaName(catalogAndSchema);
        String sql=getDB2Sql(jdbcSchemaName);
        return executeAndExtract(sql,database);
      }
 else {
        throw new RuntimeException("Cannot bulk select");
      }
    }
    protected String getDB2Sql(    String jdbcSchemaName){
      return "SELECT  " + "  pk_col.tabschema AS pktable_cat,  " + "  pk_col.tabname as pktable_name,  "+ "  pk_col.colname as pkcolumn_name, "+ "  fk_col.tabschema as fktable_cat,  "+ "  fk_col.tabname as fktable_name,  "+ "  fk_col.colname as fkcolumn_name, "+ "  fk_col.colseq as key_seq,  "+ "  decode (ref.updaterule, 'A', 3, 'R', 1, 1) as update_rule,  "+ "  decode (ref.deleterule, 'A', 3, 'C', 0, 'N', 2, 'R', 1, 1) as delete_rule,  "+ "  ref.constname as fk_name,  "+ "  ref.refkeyname as pk_name,  "+ "  7 as deferrability  "+ "FROM "+ "syscat.references ref "+ "join syscat.keycoluse fk_col on ref.constname=fk_col.constname and ref.tabschema=fk_col.tabschema and ref.tabname=fk_col.tabname "+ "join syscat.keycoluse pk_col on ref.refkeyname=pk_col.constname and ref.reftabschema=pk_col.tabschema and ref.reftabname=pk_col.tabname "+ "WHERE ref.tabschema = '" + jdbcSchemaName + "' "+ "and pk_col.colseq=fk_col.colseq "+ "ORDER BY fk_col.colseq";
    }
    @Override boolean shouldBulkSelect(    String schemaKey,    ResultSetCache resultSetCache){
      if (database instanceof DB2Database) {
        return super.shouldBulkSelect(schemaKey,resultSetCache);
      }
 else {
        return database instanceof OracleDatabase;
      }
    }
  }
);
}
