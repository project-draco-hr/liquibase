{
  try {
    String schema=referenceSnapshot.getSchema();
    for (    Table table : referenceSnapshot.getTables()) {
      List<Change> changes=new ArrayList<Change>();
      List<Map> rs=ExecutorService.getInstance().getExecutor(referenceSnapshot.getDatabase()).queryForList(new RawSqlStatement("SELECT * FROM " + referenceSnapshot.getDatabase().escapeTableName(schema,table.getName())));
      if (rs.size() == 0) {
        continue;
      }
      List<String> columnNames=new ArrayList<String>();
      for (      Column column : table.getColumns()) {
        columnNames.add(column.getName());
      }
      if (dataDir != null) {
        String fileName=table.getName().toLowerCase() + ".csv";
        if (dataDir != null) {
          fileName=dataDir + "/" + fileName;
        }
        File parentDir=new File(dataDir);
        if (!parentDir.exists()) {
          parentDir.mkdirs();
        }
        if (!parentDir.isDirectory()) {
          throw new RuntimeException(parentDir + " is not a directory");
        }
        CSVWriter outputFile=new CSVWriter(new FileWriter(fileName));
        String[] dataTypes=new String[columnNames.size()];
        String[] line=new String[columnNames.size()];
        for (int i=0; i < columnNames.size(); i++) {
          line[i]=columnNames.get(i);
        }
        outputFile.writeNext(line);
        for (        Map row : rs) {
          line=new String[columnNames.size()];
          for (int i=0; i < columnNames.size(); i++) {
            Object value=row.get(columnNames.get(i).toUpperCase());
            if (dataTypes[i] == null && value != null) {
              if (value instanceof Number) {
                dataTypes[i]="NUMERIC";
              }
 else               if (value instanceof Boolean) {
                dataTypes[i]="BOOLEAN";
              }
 else               if (value instanceof Date) {
                dataTypes[i]="DATE";
              }
 else {
                dataTypes[i]="STRING";
              }
            }
            if (value == null) {
              line[i]="NULL";
            }
 else {
              if (value instanceof Date) {
                line[i]=new ISODateFormat().format(((Date)value));
              }
 else {
                line[i]=value.toString();
              }
            }
          }
          outputFile.writeNext(line);
        }
        outputFile.flush();
        outputFile.close();
        LoadDataChange change=new LoadDataChange();
        change.setFile(fileName);
        change.setEncoding("UTF-8");
        change.setSchemaName(schema);
        change.setTableName(table.getName());
        for (int i=0; i < columnNames.size(); i++) {
          String colName=columnNames.get(i);
          LoadDataColumnConfig columnConfig=new LoadDataColumnConfig();
          columnConfig.setHeader(colName);
          columnConfig.setName(colName);
          columnConfig.setType(dataTypes[i]);
          change.addColumn(columnConfig);
        }
        changes.add(change);
      }
 else {
        for (        Map row : rs) {
          InsertDataChange change=new InsertDataChange();
          change.setSchemaName(schema);
          change.setTableName(table.getName());
          for (int i=0; i < columnNames.size(); i++) {
            ColumnConfig column=new ColumnConfig();
            column.setName(columnNames.get(i));
            Object value=row.get(columnNames.get(i).toUpperCase());
            if (value == null) {
              column.setValue(null);
            }
 else             if (value instanceof Number) {
              column.setValueNumeric((Number)value);
            }
 else             if (value instanceof Boolean) {
              column.setValueBoolean((Boolean)value);
            }
 else             if (value instanceof Date) {
              column.setValueDate((Date)value);
            }
 else {
              column.setValue(value.toString().replace("\\","\\\\"));
            }
            change.addColumn(column);
          }
          changes.add(change);
        }
      }
      if (changes.size() > 0) {
        ChangeSet changeSet=generateChangeSet();
        for (        Change change : changes) {
          changeSet.addChange(change);
        }
        changeSets.add(changeSet);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
