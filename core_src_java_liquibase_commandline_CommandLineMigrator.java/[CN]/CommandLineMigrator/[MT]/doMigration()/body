{
  if ("help".equalsIgnoreCase(command)) {
    printHelp(System.out);
    return;
  }
  if ("finest".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.FINEST);
  }
 else   if ("finer".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.FINER);
  }
 else   if ("fine".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.FINE);
  }
 else   if ("info".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.INFO);
  }
 else   if ("warning".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.WARNING);
  }
 else   if ("severe".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.SEVERE);
  }
 else   if ("off".equalsIgnoreCase(logLevel)) {
    LogFactory.getLogger().setLevel(Level.OFF);
  }
 else {
    throw new CommandLineParsingException("Unknown log level: " + logLevel);
  }
  FileSystemFileOpener fsOpener=new FileSystemFileOpener();
  CommandLineFileOpener clOpener=new CommandLineFileOpener(classLoader);
  Driver driver;
  DatabaseFactory databaseFactory=DatabaseFactory.getInstance();
  if (this.databaseClass != null) {
    databaseFactory.addDatabaseImplementation((Database)Class.forName(this.databaseClass,true,classLoader).newInstance());
  }
  try {
    if (this.driver == null) {
      this.driver=databaseFactory.findDefaultDriver(url);
    }
    if (this.driver == null) {
      throw new RuntimeException("Driver class was not specified and could not be determined from the url");
    }
    driver=(Driver)Class.forName(this.driver,true,classLoader).newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException("Cannot find database driver: " + e.getMessage());
  }
  Properties info=new Properties();
  info.put("user",username);
  if (password != null) {
    info.put("password",password);
  }
  Connection connection=driver.connect(url,info);
  if (connection == null) {
    throw new JDBCException("Connection could not be created to " + url + " with driver "+ driver.getClass().getName()+ ".  Possibly the wrong driver for the given database URL");
  }
  try {
    Database database=databaseFactory.findCorrectDatabaseImplementation(connection);
    database.setDefaultSchemaName(StringUtils.trimToNull(defaultSchemaName));
    if ("diff".equalsIgnoreCase(command)) {
      doDiff(database,createDatabaseFromCommandParams(commandParams));
      return;
    }
 else     if ("diffChangeLog".equalsIgnoreCase(command)) {
      doDiffToChangeLog(database,createDatabaseFromCommandParams(commandParams));
      return;
    }
 else     if ("generateChangeLog".equalsIgnoreCase(command)) {
      doGenerateChangeLog(database);
      return;
    }
    Migrator migrator=new Migrator(changeLogFile,new CompositeFileOpener(fsOpener,clOpener),database);
    if ("listLocks".equalsIgnoreCase(command)) {
      migrator.reportLocks(System.out);
      return;
    }
 else     if ("releaseLocks".equalsIgnoreCase(command)) {
      LockHandler.getInstance(database).forceReleaseLock();
      System.out.println("Successfully released all database change log locks for " + migrator.getDatabase().getConnectionUsername() + "@"+ migrator.getDatabase().getConnectionURL());
      return;
    }
 else     if ("tag".equalsIgnoreCase(command)) {
      migrator.tag(commandParams.iterator().next());
      System.out.println("Successfully tagged " + migrator.getDatabase().getConnectionUsername() + "@"+ migrator.getDatabase().getConnectionURL());
      return;
    }
 else     if ("dropAll".equals(command)) {
      migrator.dropAll();
      System.out.println("All objects dropped from " + migrator.getDatabase().getConnectionUsername() + "@"+ migrator.getDatabase().getConnectionURL());
      return;
    }
 else     if ("status".equalsIgnoreCase(command)) {
      boolean runVerbose=false;
      if (commandParams.contains("--verbose")) {
        runVerbose=true;
      }
      migrator.reportStatus(runVerbose,contexts,getOutputWriter());
      return;
    }
 else     if ("validate".equalsIgnoreCase(command)) {
      try {
        migrator.validate();
      }
 catch (      ValidationFailedException e) {
        e.printDescriptiveError(System.out);
        return;
      }
      System.out.println("No validation errors found");
      return;
    }
 else     if ("clearCheckSums".equalsIgnoreCase(command)) {
      migrator.clearCheckSums();
      return;
    }
 else     if ("dbdoc".equalsIgnoreCase(command)) {
      if (commandParams.size() == 0) {
        throw new CommandLineParsingException("dbdoc requires an output directory");
      }
      if (changeLogFile == null) {
        throw new CommandLineParsingException("dbdoc requires a changeLog parameter");
      }
      migrator.generateDocumentation(commandParams.iterator().next());
      return;
    }
    DateFormat dateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    try {
      if ("update".equalsIgnoreCase(command)) {
        migrator.update(contexts);
      }
 else       if ("changelogSync".equalsIgnoreCase(command)) {
        migrator.changeLogSync(contexts);
      }
 else       if ("changelogSyncSQL".equalsIgnoreCase(command)) {
        migrator.changeLogSync(contexts,getOutputWriter());
      }
 else       if ("updateCount".equalsIgnoreCase(command)) {
        migrator.update(Integer.parseInt(commandParams.iterator().next()),contexts);
      }
 else       if ("updateCountSQL".equalsIgnoreCase(command)) {
        migrator.update(Integer.parseInt(commandParams.iterator().next()),contexts,getOutputWriter());
      }
 else       if ("updateSQL".equalsIgnoreCase(command)) {
        migrator.update(contexts,getOutputWriter());
      }
 else       if ("rollback".equalsIgnoreCase(command)) {
        if (commandParams == null) {
          throw new CommandLineParsingException("rollback requires a rollback tag");
        }
        migrator.rollback(commandParams.iterator().next(),contexts);
      }
 else       if ("rollbackToDate".equalsIgnoreCase(command)) {
        if (commandParams == null) {
          throw new CommandLineParsingException("rollback requires a rollback date");
        }
        migrator.rollback(dateFormat.parse(commandParams.iterator().next()),contexts);
      }
 else       if ("rollbackCount".equalsIgnoreCase(command)) {
        migrator.rollback(Integer.parseInt(commandParams.iterator().next()),contexts);
      }
 else       if ("rollbackSQL".equalsIgnoreCase(command)) {
        if (commandParams == null) {
          throw new CommandLineParsingException("rollbackSQL requires a rollback tag");
        }
        migrator.rollback(commandParams.iterator().next(),contexts,getOutputWriter());
      }
 else       if ("rollbackToDateSQL".equalsIgnoreCase(command)) {
        if (commandParams == null) {
          throw new CommandLineParsingException("rollbackToDateSQL requires a rollback date");
        }
        migrator.rollback(dateFormat.parse(commandParams.iterator().next()),contexts,getOutputWriter());
      }
 else       if ("rollbackCountSQL".equalsIgnoreCase(command)) {
        if (commandParams == null) {
          throw new CommandLineParsingException("rollbackCountSQL requires a rollback tag");
        }
        migrator.rollback(Integer.parseInt(commandParams.iterator().next()),contexts,getOutputWriter());
      }
 else       if ("futureRollbackSQL".equalsIgnoreCase(command)) {
        migrator.futureRollbackSQL(contexts,getOutputWriter());
      }
 else {
        throw new CommandLineParsingException("Unknown command: " + command);
      }
    }
 catch (    ParseException e) {
      throw new CommandLineParsingException("Unexpected date/time format.  Use 'yyyy-MM-dd HH:mm:ss'");
    }
  }
  finally {
    connection.close();
  }
}
